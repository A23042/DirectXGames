#include "CollisionManager.h"

CollisonManager::CollisonManager()
{
	ObjectManager::SetVisible(this,false);
}

CollisonManager::~CollisonManager()
{
}

void CollisonManager::Start()
{
	balls = ObjectManager::FindGameObjects<Ball>();
	boxes = ObjectManager::FindGameObjectsWithTag<Box>("STAGEOBJ");
}

void CollisonManager::Update()
{
#if 1

	/*
	// BallをFindGameObjectsして
	// Aを保存、AからB〜Nまで衝突判定を実行
	// Aは衝突判定されたからBからC〜Nまで衝突判定
	// を繰り返す？
	*/
	

	// 衝突判定を取りに行くBallを一つづつ回す
	//std::list<Ball*> balls = ObjectManager::FindGameObjects<Ball>();
	for (Ball* checkBall : balls)
	{
		// Boxとの衝突判定
		for (Box* box : boxes)
		{
			if (box->CheckSphereAABBCollision(checkBall->pObj))
			{
				VECTOR3 refVec = VECTOR3(0, 0, 0);
				VECTOR3 pushVec = VECTOR3(0, 0, 0);
				pushVec = box->HitSphereToCubeplane(checkBall->pObj, refVec);
				PushVec(checkBall->pObj, -pushVec, refVec);
			}
		}


		// 衝突判定が行われたBallでなければ
		if (std::find(resolvedBalls.begin(), resolvedBalls.end(), checkBall) == resolvedBalls.end())
		{
			// 衝突判定を取られるBallを格納する
			for (Ball* targetBall : balls)
			{
				// 衝突判定を取りに行くBallと取られるBallが同じでなければ進
				if (targetBall != checkBall)
				{
					// checkBallからresolveBall以外すべてのtargetBallに衝突判定を取る
					// std::find(探索する先頭、末尾、探すもの)あったら？
					if (std::find(resolvedBalls.begin(), resolvedBalls.end(), targetBall) == resolvedBalls.end())
					{
						// checkBallからtargetBallに対して衝突判定
						if (HitSphereToSphere(checkBall->pObj, targetBall->pObj))
						{
							checkBall->SetPosition(checkBall->pObj.center);
							targetBall->SetPosition(targetBall->pObj.center);
						}
					}
				}
			}
		}
		// checkBallからresoleveBall以外すべてのballと衝突判定を取り終えたら
		// checkBallをresolveBallに格納する
		resolvedBalls.push_back(checkBall);
	}
	// resolveBallsをクリアする
	resolvedBalls.clear();
#endif
}

void CollisonManager::PushVec(PhysicsObject& sphere, VECTOR3 pushVec, VECTOR3 RefVec)
{
	sphere.center += pushVec;
	transform.position = sphere.center;
	if (RefVec.Length() > 0)
	{
		sphere.velocity = RefVec;
	}
	return;
}